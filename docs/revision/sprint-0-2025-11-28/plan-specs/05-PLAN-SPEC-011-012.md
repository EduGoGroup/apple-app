# Plan SPEC-011 y SPEC-012: Analytics y Performance Monitoring

**Fecha de Creacion**: 2025-11-28
**Estado Actual SPEC-011**: 0% -> 100%
**Estado Actual SPEC-012**: 0% -> 100%
**Prioridad SPEC-011**: P3 - BAJA
**Prioridad SPEC-012**: P2 - MEDIA
**Tiempo Estimado Total**: 16 horas

---

## Resumen Ejecutivo

### SPEC-011: Analytics & Telemetry

**Objetivo**: Implementar un sistema de analytics agnostico que permita:
- Tracking de eventos de usuario
- Multiples providers (Firebase, Mixpanel, Custom)
- Privacy compliance (GDPR, ATT)
- Opt-in/Opt-out de usuario

**Requisitos Externos**:

| Requisito | Proveedor | Estado | Bloquea |
|-----------|-----------|--------|---------|
| GoogleService-Info.plist | Firebase | PENDIENTE | Firebase integration |
| Privacy Policy URL | Legal | PENDIENTE | App Store submission |
| ATT consent flow | Apple | DISPONIBLE | User tracking |

### SPEC-012: Performance Monitoring

**Objetivo**: Implementar monitoreo de rendimiento que incluya:
- Launch time tracking
- Screen render metrics
- Network performance
- Memory monitoring
- Crash reporting (opcional)

**Requisitos Externos**:

| Requisito | Proveedor | Estado | Bloquea |
|-----------|-----------|--------|---------|
| Firebase Performance SDK (opcional) | Firebase | PENDIENTE | Firebase integration |

---

## Prerequisitos: Sprint 0 (Recomendado)

Aunque estas SPECs no tienen violaciones arquitectonicas directas, se recomienda completar Sprint 0 para:
1. Establecer el patron de Extensions para UI properties
2. Tener Domain Layer 100% puro como referencia
3. Mantener consistencia arquitectonica

---

## PARTE A: SPEC-011 - Analytics & Telemetry

### Arquitectura

```
apple-app/
|
+-- Domain/
|   +-- Services/
|   |   +-- AnalyticsService.swift       # Protocol puro
|   |
|   +-- Entities/
|       +-- AnalyticsEvent.swift         # Enum de eventos (sin UI)
|       +-- AnalyticsUserProperty.swift  # Propiedades de usuario
|
+-- Data/
|   +-- Services/
|       +-- Analytics/
|           +-- AnalyticsManager.swift       # Implementacion principal
|           +-- Providers/
|               +-- AnalyticsProvider.swift  # Protocol de provider
|               +-- FirebaseAnalyticsProvider.swift
|               +-- MixpanelAnalyticsProvider.swift
|               +-- ConsoleAnalyticsProvider.swift
|               +-- NoOpAnalyticsProvider.swift
|
+-- Presentation/
    +-- Extensions/
        +-- AnalyticsEvent+Description.swift  # displayName, etc.
```

### Fase A.1: Domain Layer (1h)

#### A.1.1 Crear Protocol AnalyticsService

**Archivo**: `Domain/Services/AnalyticsService.swift`

```swift
//
//  AnalyticsService.swift
//  apple-app
//
//  Protocol para el servicio de analytics
//

import Foundation

/// Protocol para el servicio de analytics
///
/// ## Clean Architecture
/// Este protocol esta en Domain Layer porque define
/// el contrato de negocio para tracking de eventos.
///
/// ## Thread Safety
/// Las implementaciones deben ser thread-safe.
protocol AnalyticsService: Sendable {
    /// Registra un evento de analytics
    ///
    /// - Parameters:
    ///   - event: El evento a registrar
    ///   - parameters: Parametros adicionales del evento
    func track(_ event: AnalyticsEvent, parameters: [String: Any]?) async

    /// Establece una propiedad de usuario
    ///
    /// - Parameters:
    ///   - property: La propiedad a establecer
    ///   - value: El valor de la propiedad
    func setUserProperty(_ property: AnalyticsUserProperty, value: String?) async

    /// Establece el ID del usuario para analytics
    ///
    /// - Parameter userId: ID del usuario, o nil para logout
    func setUserId(_ userId: String?) async

    /// Resetea todos los datos de analytics
    func reset() async

    /// Indica si el tracking esta habilitado
    var isEnabled: Bool { get async }

    /// Habilita o deshabilita el tracking
    func setEnabled(_ enabled: Bool) async
}

// MARK: - Default Implementation

extension AnalyticsService {
    /// Registra un evento sin parametros adicionales
    func track(_ event: AnalyticsEvent) async {
        await track(event, parameters: nil)
    }
}
```

#### A.1.2 Crear Enum de Eventos

**Archivo**: `Domain/Entities/AnalyticsEvent.swift`

```swift
//
//  AnalyticsEvent.swift
//  apple-app
//
//  Eventos de analytics (logica de negocio pura)
//  Las propiedades de UI estan en Presentation/Extensions/AnalyticsEvent+Description.swift
//

import Foundation

/// Eventos de analytics disponibles
///
/// ## Clean Architecture
/// Este enum es 100% puro:
/// - NO tiene propiedades de UI
/// - Solo define los tipos de eventos de negocio
/// - Las descripciones para debugging estan en una extension
///
/// - Note: Para propiedades de UI, ver `AnalyticsEvent+Description.swift`
enum AnalyticsEvent: String, Sendable, CaseIterable {
    // MARK: - Authentication Events

    /// Usuario inicio sesion
    case loginSuccess = "login_success"

    /// Intento de login fallido
    case loginFailure = "login_failure"

    /// Usuario cerro sesion
    case logout = "logout"

    /// Registro de nuevo usuario
    case signupSuccess = "signup_success"

    /// Intento de registro fallido
    case signupFailure = "signup_failure"

    /// Login con biometria exitoso
    case biometricLoginSuccess = "biometric_login_success"

    /// Login con biometria fallido
    case biometricLoginFailure = "biometric_login_failure"

    // MARK: - Navigation Events

    /// Usuario abrio una pantalla
    case screenView = "screen_view"

    /// Usuario navego hacia atras
    case navigationBack = "navigation_back"

    /// Usuario uso tab bar
    case tabSelected = "tab_selected"

    // MARK: - Feature Events

    /// Feature flag consultado
    case featureFlagChecked = "feature_flag_checked"

    /// Modo offline activado
    case offlineModeActivated = "offline_mode_activated"

    /// Sincronizacion completada
    case syncCompleted = "sync_completed"

    // MARK: - Error Events

    /// Error de red
    case networkError = "network_error"

    /// Error de la aplicacion
    case appError = "app_error"

    // MARK: - User Interaction Events

    /// Usuario realizo una busqueda
    case search = "search"

    /// Usuario cambio configuracion
    case settingsChanged = "settings_changed"

    /// Usuario cambio tema
    case themeChanged = "theme_changed"

    /// Usuario cambio idioma
    case languageChanged = "language_changed"

    // MARK: - Business Logic Properties

    /// Categoria del evento para agrupacion en dashboard
    var category: EventCategory {
        switch self {
        case .loginSuccess, .loginFailure, .logout,
             .signupSuccess, .signupFailure,
             .biometricLoginSuccess, .biometricLoginFailure:
            return .authentication

        case .screenView, .navigationBack, .tabSelected:
            return .navigation

        case .featureFlagChecked, .offlineModeActivated, .syncCompleted:
            return .feature

        case .networkError, .appError:
            return .error

        case .search, .settingsChanged, .themeChanged, .languageChanged:
            return .userInteraction
        }
    }

    /// Indica si el evento debe enviarse inmediatamente
    /// o puede agregarse en batch
    var isImmediate: Bool {
        switch self {
        case .loginSuccess, .loginFailure, .logout,
             .networkError, .appError:
            return true
        default:
            return false
        }
    }

    /// Indica si el evento contiene datos sensibles
    var containsSensitiveData: Bool {
        switch self {
        case .loginFailure, .signupFailure:
            return true  // Podria contener email/info del error
        default:
            return false
        }
    }

    /// Categorias de eventos
    enum EventCategory: String, Sendable {
        case authentication
        case navigation
        case feature
        case error
        case userInteraction
    }
}

// MARK: - Identifiable

extension AnalyticsEvent: Identifiable {
    var id: String { rawValue }
}
```

#### A.1.3 Crear User Properties

**Archivo**: `Domain/Entities/AnalyticsUserProperty.swift`

```swift
//
//  AnalyticsUserProperty.swift
//  apple-app
//
//  Propiedades de usuario para analytics
//

import Foundation

/// Propiedades de usuario para analytics
enum AnalyticsUserProperty: String, Sendable, CaseIterable {
    /// Rol del usuario
    case userRole = "user_role"

    /// Tema preferido
    case preferredTheme = "preferred_theme"

    /// Idioma preferido
    case preferredLanguage = "preferred_language"

    /// Tipo de suscripcion
    case subscriptionType = "subscription_type"

    /// Version de la app instalada
    case appVersion = "app_version"

    /// Plataforma (iOS, iPadOS, macOS, visionOS)
    case platform = "platform"

    /// Si tiene biometria habilitada
    case biometricEnabled = "biometric_enabled"

    /// Si tiene notificaciones habilitadas
    case notificationsEnabled = "notifications_enabled"

    /// Indica si la propiedad requiere consentimiento explicito
    var requiresConsent: Bool {
        switch self {
        case .userRole, .subscriptionType:
            return true
        default:
            return false
        }
    }
}
```

### Fase A.2: Data Layer (3h)

#### A.2.1 Crear Protocol de Provider

**Archivo**: `Data/Services/Analytics/Providers/AnalyticsProvider.swift`

```swift
//
//  AnalyticsProvider.swift
//  apple-app
//
//  Protocol para providers de analytics
//

import Foundation

/// Protocol que implementan los diferentes providers de analytics
///
/// Cada provider (Firebase, Mixpanel, etc.) implementa este protocol.
protocol AnalyticsProvider: Sendable {
    /// Nombre del provider para logging
    var name: String { get }

    /// Indica si el provider esta disponible
    var isAvailable: Bool { get }

    /// Inicializa el provider
    func initialize() async

    /// Registra un evento
    func logEvent(_ name: String, parameters: [String: Any]?) async

    /// Establece una propiedad de usuario
    func setUserProperty(_ name: String, value: String?) async

    /// Establece el ID del usuario
    func setUserId(_ userId: String?) async

    /// Resetea el provider
    func reset() async
}
```

#### A.2.2 Crear ConsoleAnalyticsProvider (DEBUG)

**Archivo**: `Data/Services/Analytics/Providers/ConsoleAnalyticsProvider.swift`

```swift
//
//  ConsoleAnalyticsProvider.swift
//  apple-app
//
//  Provider que imprime eventos a consola (para DEBUG)
//

import Foundation

/// Provider de analytics que imprime a consola
///
/// Util para desarrollo y debugging.
struct ConsoleAnalyticsProvider: AnalyticsProvider {
    let name = "Console"
    let isAvailable = true

    private let logger: Logger

    init(logger: Logger = LoggerFactory.analytics) {
        self.logger = logger
    }

    func initialize() async {
        logger.info("[Analytics] Console provider initialized")
    }

    func logEvent(_ name: String, parameters: [String: Any]?) async {
        var message = "[Analytics] Event: \(name)"
        if let params = parameters, !params.isEmpty {
            message += " | Params: \(params)"
        }
        logger.info("\(message)")
    }

    func setUserProperty(_ name: String, value: String?) async {
        logger.info("[Analytics] User Property: \(name) = \(value ?? "nil")")
    }

    func setUserId(_ userId: String?) async {
        logger.info("[Analytics] User ID: \(userId ?? "nil")")
    }

    func reset() async {
        logger.info("[Analytics] Console provider reset")
    }
}
```

#### A.2.3 Crear FirebaseAnalyticsProvider

**Archivo**: `Data/Services/Analytics/Providers/FirebaseAnalyticsProvider.swift`

```swift
//
//  FirebaseAnalyticsProvider.swift
//  apple-app
//
//  Provider de Firebase Analytics
//

import Foundation
// import FirebaseAnalytics  // Descomentar cuando Firebase este integrado

/// Provider de Firebase Analytics
///
/// ## Requisitos
/// - GoogleService-Info.plist configurado
/// - Firebase SDK integrado
struct FirebaseAnalyticsProvider: AnalyticsProvider {
    let name = "Firebase"

    var isAvailable: Bool {
        // Verificar que Firebase esta configurado
        #if canImport(FirebaseAnalytics)
        return true
        #else
        return false
        #endif
    }

    private let logger: Logger

    init(logger: Logger = LoggerFactory.analytics) {
        self.logger = logger
    }

    func initialize() async {
        guard isAvailable else {
            logger.warning("[Firebase] Not available - Firebase SDK not imported")
            return
        }

        // FirebaseApp.configure() se llama en apple_appApp.swift
        logger.info("[Firebase] Provider initialized")
    }

    func logEvent(_ name: String, parameters: [String: Any]?) async {
        guard isAvailable else { return }

        // Analytics.logEvent(name, parameters: parameters)
        logger.debug("[Firebase] Event: \(name)")
    }

    func setUserProperty(_ name: String, value: String?) async {
        guard isAvailable else { return }

        // Analytics.setUserProperty(value, forName: name)
        logger.debug("[Firebase] User Property: \(name) = \(value ?? "nil")")
    }

    func setUserId(_ userId: String?) async {
        guard isAvailable else { return }

        // Analytics.setUserID(userId)
        logger.debug("[Firebase] User ID: \(userId ?? "nil")")
    }

    func reset() async {
        guard isAvailable else { return }

        // Analytics.resetAnalyticsData()
        logger.debug("[Firebase] Reset analytics data")
    }
}
```

#### A.2.4 Crear NoOpAnalyticsProvider

**Archivo**: `Data/Services/Analytics/Providers/NoOpAnalyticsProvider.swift`

```swift
//
//  NoOpAnalyticsProvider.swift
//  apple-app
//
//  Provider que no hace nada (para cuando tracking esta deshabilitado)
//

import Foundation

/// Provider que no hace nada
///
/// Se usa cuando el usuario ha optado out del tracking.
struct NoOpAnalyticsProvider: AnalyticsProvider {
    let name = "NoOp"
    let isAvailable = true

    func initialize() async {}
    func logEvent(_ name: String, parameters: [String: Any]?) async {}
    func setUserProperty(_ name: String, value: String?) async {}
    func setUserId(_ userId: String?) async {}
    func reset() async {}
}
```

#### A.2.5 Crear AnalyticsManager

**Archivo**: `Data/Services/Analytics/AnalyticsManager.swift`

```swift
//
//  AnalyticsManager.swift
//  apple-app
//
//  Implementacion principal del servicio de analytics
//

import Foundation
import AppTrackingTransparency

/// Implementacion del servicio de analytics
///
/// ## Thread Safety
/// Implementado como `actor` porque:
/// 1. Mantiene estado mutable (providers, enabled)
/// 2. Se accede desde multiples contextos
/// 3. Coordina multiples providers
actor AnalyticsManager: AnalyticsService {
    // MARK: - Properties

    private var providers: [AnalyticsProvider] = []
    private var _isEnabled: Bool = true
    private let logger: Logger

    // MARK: - Singleton

    static let shared = AnalyticsManager()

    // MARK: - Init

    private init(logger: Logger = LoggerFactory.analytics) {
        self.logger = logger
    }

    // MARK: - Configuration

    /// Configura los providers de analytics
    ///
    /// - Parameter providers: Lista de providers a usar
    func configure(with providers: [AnalyticsProvider]) async {
        self.providers = providers

        for provider in providers {
            await provider.initialize()
        }

        logger.info("Analytics configured",
                   metadata: ["providers": providers.map { $0.name }.joined(separator: ", ")])
    }

    // MARK: - AnalyticsService

    var isEnabled: Bool {
        _isEnabled
    }

    func setEnabled(_ enabled: Bool) async {
        _isEnabled = enabled
        logger.info("Analytics enabled: \(enabled)")

        if !enabled {
            // Reset cuando se deshabilita
            await reset()
        }
    }

    func track(_ event: AnalyticsEvent, parameters: [String: Any]?) async {
        guard _isEnabled else {
            logger.debug("Analytics disabled, skipping event: \(event.rawValue)")
            return
        }

        // Verificar ATT si el evento contiene datos sensibles
        if event.containsSensitiveData {
            let status = ATTrackingManager.trackingAuthorizationStatus
            if status != .authorized {
                logger.debug("ATT not authorized, skipping sensitive event: \(event.rawValue)")
                return
            }
        }

        // Enriquecer parametros
        var enrichedParams = parameters ?? [:]
        enrichedParams["event_category"] = event.category.rawValue
        enrichedParams["timestamp"] = ISO8601DateFormatter().string(from: Date())

        // Enviar a todos los providers
        for provider in providers where provider.isAvailable {
            await provider.logEvent(event.rawValue, parameters: enrichedParams)
        }

        logger.debug("Event tracked: \(event.rawValue)",
                    metadata: ["category": event.category.rawValue])
    }

    func setUserProperty(_ property: AnalyticsUserProperty, value: String?) async {
        guard _isEnabled else { return }

        // Verificar si requiere consentimiento
        if property.requiresConsent {
            let status = ATTrackingManager.trackingAuthorizationStatus
            if status != .authorized {
                logger.debug("ATT not authorized, skipping property: \(property.rawValue)")
                return
            }
        }

        for provider in providers where provider.isAvailable {
            await provider.setUserProperty(property.rawValue, value: value)
        }

        logger.debug("User property set: \(property.rawValue) = \(value ?? "nil")")
    }

    func setUserId(_ userId: String?) async {
        guard _isEnabled else { return }

        for provider in providers where provider.isAvailable {
            await provider.setUserId(userId)
        }

        logger.debug("User ID set: \(userId ?? "nil")")
    }

    func reset() async {
        for provider in providers where provider.isAvailable {
            await provider.reset()
        }

        logger.info("Analytics reset")
    }

    // MARK: - ATT

    /// Solicita permiso de tracking (ATT)
    ///
    /// - Returns: El status de autorizacion
    @MainActor
    func requestTrackingAuthorization() async -> ATTrackingManager.AuthorizationStatus {
        // Esperar a que la UI este lista
        try? await Task.sleep(nanoseconds: 1_000_000_000)  // 1 segundo

        let status = await ATTrackingManager.requestTrackingAuthorization()

        logger.info("ATT authorization requested",
                   metadata: ["status": "\(status.rawValue)"])

        // Si no autorizado, usar NoOp provider
        if status != .authorized {
            await configure(with: [NoOpAnalyticsProvider()])
        }

        return status
    }
}
```

### Fase A.3: Presentation Layer (30min)

#### A.3.1 Crear Extension de Descripcion

**Archivo**: `Presentation/Extensions/AnalyticsEvent+Description.swift`

```swift
//
//  AnalyticsEvent+Description.swift
//  apple-app
//
//  Extension de AnalyticsEvent para propiedades de UI
//

import SwiftUI

/// Extension de AnalyticsEvent con propiedades de UI
///
/// Separado de Domain para mantener Clean Architecture.
extension AnalyticsEvent {
    /// Nombre para mostrar en UI (para debugging/admin)
    var displayName: String {
        switch self {
        case .loginSuccess: return "Login Exitoso"
        case .loginFailure: return "Login Fallido"
        case .logout: return "Logout"
        case .signupSuccess: return "Registro Exitoso"
        case .signupFailure: return "Registro Fallido"
        case .biometricLoginSuccess: return "Login Biometrico Exitoso"
        case .biometricLoginFailure: return "Login Biometrico Fallido"
        case .screenView: return "Vista de Pantalla"
        case .navigationBack: return "Navegacion Atras"
        case .tabSelected: return "Tab Seleccionado"
        case .featureFlagChecked: return "Feature Flag Consultado"
        case .offlineModeActivated: return "Modo Offline Activado"
        case .syncCompleted: return "Sincronizacion Completada"
        case .networkError: return "Error de Red"
        case .appError: return "Error de App"
        case .search: return "Busqueda"
        case .settingsChanged: return "Configuracion Cambiada"
        case .themeChanged: return "Tema Cambiado"
        case .languageChanged: return "Idioma Cambiado"
        }
    }

    /// Icono SF Symbol para el evento
    var iconName: String {
        switch category {
        case .authentication: return "person.badge.key"
        case .navigation: return "arrow.left.arrow.right"
        case .feature: return "flag"
        case .error: return "exclamationmark.triangle"
        case .userInteraction: return "hand.tap"
        }
    }

    /// Color asociado a la categoria
    var color: Color {
        switch category {
        case .authentication: return .blue
        case .navigation: return .green
        case .feature: return .purple
        case .error: return .red
        case .userInteraction: return .orange
        }
    }
}

/// Extension de categoria para UI
extension AnalyticsEvent.EventCategory {
    var displayName: String {
        switch self {
        case .authentication: return "Autenticacion"
        case .navigation: return "Navegacion"
        case .feature: return "Funcionalidades"
        case .error: return "Errores"
        case .userInteraction: return "Interaccion"
        }
    }
}
```

### Fase A.4: Integracion y Testing (3h)

#### A.4.1 Integrar con DependencyContainer

```swift
// Core/DI/DependencyContainer+Setup.swift

func setupAnalyticsDependencies() async {
    let providers: [AnalyticsProvider]

    #if DEBUG
    providers = [ConsoleAnalyticsProvider()]
    #else
    providers = [
        FirebaseAnalyticsProvider(),
        ConsoleAnalyticsProvider()  // Para logging adicional
    ]
    #endif

    await AnalyticsManager.shared.configure(with: providers)

    register(AnalyticsService.self, scope: .singleton) {
        AnalyticsManager.shared
    }
}
```

#### A.4.2 Tests

**Archivo**: `apple-appTests/Data/Services/AnalyticsManagerTests.swift`

```swift
import Testing
import Foundation
@testable import apple_app

@Suite("AnalyticsManager Tests")
struct AnalyticsManagerTests {
    @Test("Registra evento cuando esta habilitado")
    func tracksWhenEnabled() async {
        let mockProvider = MockAnalyticsProvider()
        let sut = AnalyticsManager.shared

        await sut.configure(with: [mockProvider])
        await sut.setEnabled(true)

        await sut.track(.loginSuccess, parameters: nil)

        #expect(await mockProvider.lastEvent == "login_success")
    }

    @Test("No registra evento cuando esta deshabilitado")
    func doesNotTrackWhenDisabled() async {
        let mockProvider = MockAnalyticsProvider()
        let sut = AnalyticsManager.shared

        await sut.configure(with: [mockProvider])
        await sut.setEnabled(false)

        await sut.track(.loginSuccess, parameters: nil)

        #expect(await mockProvider.lastEvent == nil)
    }
}

// Mock Provider
actor MockAnalyticsProvider: AnalyticsProvider {
    nonisolated let name = "Mock"
    nonisolated let isAvailable = true

    var lastEvent: String?
    var lastUserId: String?

    func initialize() async {}

    func logEvent(_ name: String, parameters: [String: Any]?) async {
        lastEvent = name
    }

    func setUserProperty(_ name: String, value: String?) async {}

    func setUserId(_ userId: String?) async {
        lastUserId = userId
    }

    func reset() async {
        lastEvent = nil
        lastUserId = nil
    }
}
```

### Estimacion SPEC-011

| Tarea | Tiempo |
|-------|--------|
| Fase A.1: Domain Layer | 1h |
| Fase A.2: Data Layer | 3h |
| Fase A.3: Presentation Layer | 30min |
| Fase A.4: Integracion y Testing | 3h |
| Documentacion | 30min |
| **Total SPEC-011** | **8h** |

---

## PARTE B: SPEC-012 - Performance Monitoring

### Arquitectura

```
apple-app/
|
+-- Domain/
|   +-- Services/
|       +-- PerformanceMonitor.swift  # Protocol puro
|
+-- Data/
|   +-- Services/
|       +-- Performance/
|           +-- DefaultPerformanceMonitor.swift
|           +-- MetricsCollector.swift
|           +-- LaunchTimeTracker.swift
|           +-- NetworkMetricsTracker.swift
|           +-- MemoryMonitor.swift
|
+-- Presentation/
    +-- (Sin extension - Performance no tiene UI properties)
```

### Fase B.1: Domain Layer (30min)

#### B.1.1 Crear Protocol PerformanceMonitor

**Archivo**: `Domain/Services/PerformanceMonitor.swift`

```swift
//
//  PerformanceMonitor.swift
//  apple-app
//
//  Protocol para el servicio de monitoreo de rendimiento
//

import Foundation

/// Protocol para el servicio de performance monitoring
///
/// ## Clean Architecture
/// Este protocol esta en Domain Layer porque define
/// el contrato de negocio para monitoreo de rendimiento.
protocol PerformanceMonitor: Sendable {
    /// Registra el inicio de una operacion
    ///
    /// - Parameters:
    ///   - name: Nombre de la operacion
    ///   - category: Categoria de la metrica
    /// - Returns: Token para finalizar el tracking
    func startTrace(_ name: String, category: MetricCategory) -> TraceToken

    /// Finaliza una operacion y registra la duracion
    ///
    /// - Parameter token: Token retornado por startTrace
    func endTrace(_ token: TraceToken) async

    /// Registra una metrica numerica
    ///
    /// - Parameters:
    ///   - name: Nombre de la metrica
    ///   - value: Valor de la metrica
    ///   - unit: Unidad de medida
    func recordMetric(_ name: String, value: Double, unit: MetricUnit) async

    /// Obtiene metricas recientes
    ///
    /// - Parameter category: Categoria a filtrar, o nil para todas
    /// - Returns: Lista de metricas
    func getRecentMetrics(category: MetricCategory?) async -> [PerformanceMetric]

    /// Limpia metricas antiguas
    func pruneOldMetrics() async
}

/// Token para tracking de operaciones
struct TraceToken: Sendable {
    let id: UUID
    let name: String
    let category: MetricCategory
    let startTime: Date
}

/// Categorias de metricas
enum MetricCategory: String, Sendable, CaseIterable {
    case appLaunch = "app_launch"
    case screenRender = "screen_render"
    case networkRequest = "network_request"
    case memoryUsage = "memory_usage"
    case diskIO = "disk_io"
    case custom = "custom"
}

/// Unidades de metricas
enum MetricUnit: String, Sendable {
    case milliseconds = "ms"
    case seconds = "s"
    case bytes = "bytes"
    case megabytes = "MB"
    case percent = "%"
    case count = "count"
}

/// Modelo de metrica de rendimiento
struct PerformanceMetric: Sendable, Identifiable {
    let id: UUID
    let name: String
    let category: MetricCategory
    let value: Double
    let unit: MetricUnit
    let timestamp: Date
    let metadata: [String: String]?
}
```

### Fase B.2: Data Layer (5h)

#### B.2.1 Crear DefaultPerformanceMonitor

**Archivo**: `Data/Services/Performance/DefaultPerformanceMonitor.swift`

```swift
//
//  DefaultPerformanceMonitor.swift
//  apple-app
//
//  Implementacion del monitor de rendimiento
//

import Foundation

/// Implementacion del monitor de rendimiento
///
/// ## Thread Safety
/// Implementado como `actor` porque:
/// 1. Mantiene estado mutable (metricas, traces activos)
/// 2. Se accede desde multiples contextos
actor DefaultPerformanceMonitor: PerformanceMonitor {
    // MARK: - Properties

    private var activeTraces: [UUID: TraceToken] = [:]
    private var metrics: [PerformanceMetric] = []
    private let maxMetricsCount = 1000
    private let logger: Logger

    // MARK: - Singleton

    static let shared = DefaultPerformanceMonitor()

    // MARK: - Init

    private init(logger: Logger = LoggerFactory.performance) {
        self.logger = logger
    }

    // MARK: - PerformanceMonitor

    nonisolated func startTrace(_ name: String, category: MetricCategory) -> TraceToken {
        let token = TraceToken(
            id: UUID(),
            name: name,
            category: category,
            startTime: Date()
        )

        Task {
            await self.storeActiveTrace(token)
        }

        return token
    }

    private func storeActiveTrace(_ token: TraceToken) {
        activeTraces[token.id] = token
        logger.debug("Trace started: \(token.name)", metadata: ["category": token.category.rawValue])
    }

    func endTrace(_ token: TraceToken) async {
        guard activeTraces.removeValue(forKey: token.id) != nil else {
            logger.warning("Trace not found: \(token.id)")
            return
        }

        let duration = Date().timeIntervalSince(token.startTime) * 1000  // Convert to ms

        let metric = PerformanceMetric(
            id: UUID(),
            name: token.name,
            category: token.category,
            value: duration,
            unit: .milliseconds,
            timestamp: Date(),
            metadata: nil
        )

        metrics.append(metric)
        await pruneIfNeeded()

        logger.debug("Trace ended: \(token.name)",
                    metadata: [
                        "duration_ms": "\(Int(duration))",
                        "category": token.category.rawValue
                    ])

        // Alertar si supera umbral
        await checkThreshold(metric)
    }

    func recordMetric(_ name: String, value: Double, unit: MetricUnit) async {
        let metric = PerformanceMetric(
            id: UUID(),
            name: name,
            category: .custom,
            value: value,
            unit: unit,
            timestamp: Date(),
            metadata: nil
        )

        metrics.append(metric)
        await pruneIfNeeded()

        logger.debug("Metric recorded: \(name) = \(value) \(unit.rawValue)")
    }

    func getRecentMetrics(category: MetricCategory?) async -> [PerformanceMetric] {
        if let category = category {
            return metrics.filter { $0.category == category }
        }
        return metrics
    }

    func pruneOldMetrics() async {
        let cutoff = Date().addingTimeInterval(-3600)  // 1 hora
        metrics.removeAll { $0.timestamp < cutoff }
        logger.debug("Pruned old metrics, remaining: \(metrics.count)")
    }

    // MARK: - Private

    private func pruneIfNeeded() async {
        if metrics.count > maxMetricsCount {
            metrics.removeFirst(metrics.count - maxMetricsCount)
            logger.debug("Pruned metrics to max count: \(maxMetricsCount)")
        }
    }

    private func checkThreshold(_ metric: PerformanceMetric) async {
        let thresholds: [MetricCategory: Double] = [
            .appLaunch: 2000,       // 2 segundos
            .screenRender: 100,     // 100ms
            .networkRequest: 5000,  // 5 segundos
        ]

        guard let threshold = thresholds[metric.category],
              metric.value > threshold else {
            return
        }

        logger.warning("Performance threshold exceeded",
                      metadata: [
                          "metric": metric.name,
                          "value": "\(Int(metric.value))\(metric.unit.rawValue)",
                          "threshold": "\(Int(threshold))\(metric.unit.rawValue)"
                      ])
    }
}
```

#### B.2.2 Crear LaunchTimeTracker

**Archivo**: `Data/Services/Performance/LaunchTimeTracker.swift`

```swift
//
//  LaunchTimeTracker.swift
//  apple-app
//
//  Tracker de tiempo de inicio de la app
//

import Foundation

/// Tracker de tiempo de inicio
///
/// Se inicializa lo mas temprano posible en el ciclo de vida de la app.
enum LaunchTimeTracker {
    // MARK: - State

    private static var processStartTime: Date?
    private static var appDelegateStartTime: Date?
    private static var firstFrameTime: Date?

    // MARK: - Marks

    /// Marca el inicio del proceso (llamar en main.swift si existe)
    static func markProcessStart() {
        processStartTime = Date()
    }

    /// Marca el inicio del App delegate/SwiftUI App
    static func markAppDelegateStart() {
        appDelegateStartTime = Date()
    }

    /// Marca cuando el primer frame esta listo
    static func markFirstFrameRendered() {
        firstFrameTime = Date()

        // Registrar metricas
        Task {
            await recordLaunchMetrics()
        }
    }

    // MARK: - Metrics

    private static func recordLaunchMetrics() async {
        let monitor = DefaultPerformanceMonitor.shared

        // Tiempo total de launch
        if let processStart = processStartTime,
           let firstFrame = firstFrameTime {
            let totalLaunchTime = firstFrame.timeIntervalSince(processStart) * 1000
            await monitor.recordMetric(
                "total_launch_time",
                value: totalLaunchTime,
                unit: .milliseconds
            )
        }

        // Tiempo pre-main
        if let processStart = processStartTime,
           let appStart = appDelegateStartTime {
            let preMainTime = appStart.timeIntervalSince(processStart) * 1000
            await monitor.recordMetric(
                "pre_main_time",
                value: preMainTime,
                unit: .milliseconds
            )
        }

        // Tiempo post-main
        if let appStart = appDelegateStartTime,
           let firstFrame = firstFrameTime {
            let postMainTime = firstFrame.timeIntervalSince(appStart) * 1000
            await monitor.recordMetric(
                "post_main_time",
                value: postMainTime,
                unit: .milliseconds
            )
        }
    }

    // MARK: - Computed

    /// Tiempo total de launch en ms
    static var totalLaunchTime: Double? {
        guard let processStart = processStartTime,
              let firstFrame = firstFrameTime else {
            return nil
        }
        return firstFrame.timeIntervalSince(processStart) * 1000
    }
}
```

#### B.2.3 Crear MemoryMonitor

**Archivo**: `Data/Services/Performance/MemoryMonitor.swift`

```swift
//
//  MemoryMonitor.swift
//  apple-app
//
//  Monitor de uso de memoria
//

import Foundation

/// Monitor de uso de memoria
actor MemoryMonitor {
    // MARK: - Properties

    private var isMonitoring: Bool = false
    private let performanceMonitor: PerformanceMonitor
    private let logger: Logger
    private let warningThresholdMB: Double = 200
    private let criticalThresholdMB: Double = 500

    // MARK: - Singleton

    static let shared = MemoryMonitor()

    // MARK: - Init

    private init(
        performanceMonitor: PerformanceMonitor = DefaultPerformanceMonitor.shared,
        logger: Logger = LoggerFactory.performance
    ) {
        self.performanceMonitor = performanceMonitor
        self.logger = logger
    }

    // MARK: - Public

    /// Inicia el monitoreo periodico
    func startMonitoring(interval: TimeInterval = 30) async {
        guard !isMonitoring else { return }
        isMonitoring = true

        logger.info("Memory monitoring started", metadata: ["interval": "\(interval)s"])

        while isMonitoring {
            await recordMemoryMetric()
            try? await Task.sleep(nanoseconds: UInt64(interval * 1_000_000_000))
        }
    }

    /// Detiene el monitoreo
    func stopMonitoring() {
        isMonitoring = false
        logger.info("Memory monitoring stopped")
    }

    /// Obtiene el uso de memoria actual
    nonisolated func currentMemoryUsage() -> MemoryUsage {
        var info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size) / 4

        let result = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)
            }
        }

        guard result == KERN_SUCCESS else {
            return MemoryUsage(residentBytes: 0, virtualBytes: 0)
        }

        return MemoryUsage(
            residentBytes: UInt64(info.resident_size),
            virtualBytes: UInt64(info.virtual_size)
        )
    }

    // MARK: - Private

    private func recordMemoryMetric() async {
        let usage = currentMemoryUsage()
        let usageMB = Double(usage.residentBytes) / 1_000_000

        await performanceMonitor.recordMetric(
            "memory_usage",
            value: usageMB,
            unit: .megabytes
        )

        // Check thresholds
        if usageMB > criticalThresholdMB {
            logger.critical("Memory usage critical",
                          metadata: ["usage_mb": "\(Int(usageMB))"])
        } else if usageMB > warningThresholdMB {
            logger.warning("Memory usage high",
                         metadata: ["usage_mb": "\(Int(usageMB))"])
        }
    }
}

/// Modelo de uso de memoria
struct MemoryUsage: Sendable {
    let residentBytes: UInt64
    let virtualBytes: UInt64

    var residentMB: Double {
        Double(residentBytes) / 1_000_000
    }

    var virtualMB: Double {
        Double(virtualBytes) / 1_000_000
    }
}
```

#### B.2.4 Crear NetworkMetricsTracker

**Archivo**: `Data/Services/Performance/NetworkMetricsTracker.swift`

```swift
//
//  NetworkMetricsTracker.swift
//  apple-app
//
//  Tracker de metricas de red
//

import Foundation

/// Tracker de metricas de red
///
/// Se integra con APIClient para tracking automatico.
actor NetworkMetricsTracker {
    // MARK: - Properties

    private let performanceMonitor: PerformanceMonitor
    private let logger: Logger
    private var activeRequests: [UUID: RequestMetric] = [:]

    // MARK: - Types

    private struct RequestMetric {
        let url: String
        let method: String
        let startTime: Date
        let requestSize: Int
    }

    // MARK: - Singleton

    static let shared = NetworkMetricsTracker()

    // MARK: - Init

    private init(
        performanceMonitor: PerformanceMonitor = DefaultPerformanceMonitor.shared,
        logger: Logger = LoggerFactory.performance
    ) {
        self.performanceMonitor = performanceMonitor
        self.logger = logger
    }

    // MARK: - Public

    /// Inicia tracking de una request
    func startRequest(
        id: UUID,
        url: String,
        method: String,
        requestSize: Int
    ) {
        activeRequests[id] = RequestMetric(
            url: url,
            method: method,
            startTime: Date(),
            requestSize: requestSize
        )
    }

    /// Finaliza tracking de una request
    func endRequest(
        id: UUID,
        responseSize: Int,
        statusCode: Int?,
        error: Error?
    ) async {
        guard let metric = activeRequests.removeValue(forKey: id) else {
            return
        }

        let duration = Date().timeIntervalSince(metric.startTime) * 1000  // ms

        // Registrar duracion
        await performanceMonitor.recordMetric(
            "network_request_duration",
            value: duration,
            unit: .milliseconds
        )

        // Registrar tamano
        await performanceMonitor.recordMetric(
            "network_request_size",
            value: Double(metric.requestSize),
            unit: .bytes
        )

        await performanceMonitor.recordMetric(
            "network_response_size",
            value: Double(responseSize),
            unit: .bytes
        )

        // Log
        let success = error == nil && (statusCode ?? 0) < 400
        if success {
            logger.debug("Network request completed",
                        metadata: [
                            "url": metric.url,
                            "method": metric.method,
                            "duration_ms": "\(Int(duration))",
                            "status": "\(statusCode ?? 0)"
                        ])
        } else {
            logger.warning("Network request failed",
                         metadata: [
                             "url": metric.url,
                             "method": metric.method,
                             "duration_ms": "\(Int(duration))",
                             "error": error?.localizedDescription ?? "Unknown"
                         ])
        }
    }

    /// Obtiene estadisticas de red
    func getStatistics() async -> NetworkStatistics {
        let metrics = await performanceMonitor.getRecentMetrics(category: .networkRequest)

        let durations = metrics.filter { $0.name == "network_request_duration" }
        let avgDuration = durations.isEmpty ? 0 : durations.map { $0.value }.reduce(0, +) / Double(durations.count)

        return NetworkStatistics(
            totalRequests: durations.count,
            averageDuration: avgDuration,
            slowestRequest: durations.max(by: { $0.value < $1.value })?.value ?? 0
        )
    }
}

/// Estadisticas de red
struct NetworkStatistics: Sendable {
    let totalRequests: Int
    let averageDuration: Double  // ms
    let slowestRequest: Double   // ms
}
```

### Fase B.3: Integracion (1.5h)

#### B.3.1 Integrar con apple_appApp.swift

```swift
// apple_appApp.swift

@main
struct EduGoApp: App {
    init() {
        // Marcar inicio
        LaunchTimeTracker.markAppDelegateStart()

        // Setup dependencies
        setupDependencies()

        // Iniciar memory monitoring
        Task {
            await MemoryMonitor.shared.startMonitoring(interval: 60)
        }
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
                .onAppear {
                    LaunchTimeTracker.markFirstFrameRendered()
                }
        }
    }
}
```

#### B.3.2 Integrar con APIClient

```swift
// Data/Network/APIClient.swift

// En el metodo execute, agregar:

let requestId = UUID()

// Antes de la request:
await NetworkMetricsTracker.shared.startRequest(
    id: requestId,
    url: endpoint.url.absoluteString,
    method: method.rawValue,
    requestSize: body?.count ?? 0
)

// Despues de la request:
await NetworkMetricsTracker.shared.endRequest(
    id: requestId,
    responseSize: data.count,
    statusCode: response.statusCode,
    error: error
)
```

### Fase B.4: Testing (1h)

**Archivo**: `apple-appTests/Data/Services/PerformanceMonitorTests.swift`

```swift
import Testing
import Foundation
@testable import apple_app

@Suite("PerformanceMonitor Tests")
struct PerformanceMonitorTests {
    @Test("Registra trace correctamente")
    func recordsTraceCorrectly() async {
        let sut = DefaultPerformanceMonitor.shared

        let token = sut.startTrace("test_operation", category: .custom)

        // Simular operacion
        try? await Task.sleep(nanoseconds: 100_000_000)  // 100ms

        await sut.endTrace(token)

        let metrics = await sut.getRecentMetrics(category: .custom)
        let testMetric = metrics.first { $0.name == "test_operation" }

        #expect(testMetric != nil)
        #expect(testMetric?.value ?? 0 >= 100)  // Al menos 100ms
    }

    @Test("Registra metrica numerica")
    func recordsNumericMetric() async {
        let sut = DefaultPerformanceMonitor.shared

        await sut.recordMetric("test_metric", value: 42.5, unit: .milliseconds)

        let metrics = await sut.getRecentMetrics(category: .custom)
        let testMetric = metrics.first { $0.name == "test_metric" }

        #expect(testMetric?.value == 42.5)
        #expect(testMetric?.unit == .milliseconds)
    }

    @Test("Prune elimina metricas antiguas")
    func pruneRemovesOldMetrics() async {
        let sut = DefaultPerformanceMonitor.shared

        // Agregar metricas
        for i in 0..<10 {
            await sut.recordMetric("metric_\(i)", value: Double(i), unit: .count)
        }

        // Verificar que hay metricas
        var metrics = await sut.getRecentMetrics(category: nil)
        let initialCount = metrics.count

        // Prune (en este caso no deberia eliminar nada porque son recientes)
        await sut.pruneOldMetrics()

        metrics = await sut.getRecentMetrics(category: nil)
        #expect(metrics.count <= initialCount)
    }
}
```

### Estimacion SPEC-012

| Tarea | Tiempo |
|-------|--------|
| Fase B.1: Domain Layer | 30min |
| Fase B.2: Data Layer | 5h |
| Fase B.3: Integracion | 1.5h |
| Fase B.4: Testing | 1h |
| **Total SPEC-012** | **8h** |

---

## Cronograma de Implementacion Combinado

```
Sprint Analytics + Performance (16h total):
|
+-- Dia 1 (8h): SPEC-011 Analytics
|   |
|   +-- 0:00 - 1:00  Domain Layer
|   +-- 1:00 - 4:00  Data Layer (Providers, Manager)
|   +-- 4:00 - 4:30  Presentation Layer
|   +-- 4:30 - 7:30  Integracion y Testing
|   +-- 7:30 - 8:00  Documentacion
|
+-- Dia 2 (8h): SPEC-012 Performance
    |
    +-- 0:00 - 0:30  Domain Layer
    +-- 0:30 - 5:30  Data Layer (Monitor, Trackers)
    +-- 5:30 - 7:00  Integracion
    +-- 7:00 - 8:00  Testing
```

---

## Checklist de Completitud

### SPEC-011: Analytics

- [ ] Domain/Services/AnalyticsService.swift creado
- [ ] Domain/Entities/AnalyticsEvent.swift creado
- [ ] Domain/Entities/AnalyticsUserProperty.swift creado
- [ ] Data/Services/Analytics/Providers/*.swift creados
- [ ] Data/Services/Analytics/AnalyticsManager.swift creado
- [ ] Presentation/Extensions/AnalyticsEvent+Description.swift creado
- [ ] DependencyContainer integrado
- [ ] Tests pasando
- [ ] ATT consent implementado

### SPEC-012: Performance

- [ ] Domain/Services/PerformanceMonitor.swift creado
- [ ] Data/Services/Performance/DefaultPerformanceMonitor.swift creado
- [ ] Data/Services/Performance/LaunchTimeTracker.swift creado
- [ ] Data/Services/Performance/MemoryMonitor.swift creado
- [ ] Data/Services/Performance/NetworkMetricsTracker.swift creado
- [ ] Integracion con apple_appApp.swift
- [ ] Integracion con APIClient
- [ ] Tests pasando

---

## Criterios de Exito

| SPEC | Criterio | Metrica |
|------|----------|---------|
| 011 | Analytics tracking | Eventos se registran correctamente |
| 011 | Privacy compliance | ATT consent funcional |
| 011 | Multiple providers | Al menos 2 providers funcionando |
| 012 | Launch tracking | Tiempo de launch registrado |
| 012 | Memory monitoring | Alertas de memoria funcionando |
| 012 | Network metrics | Metricas de red registradas |

---

**Documento creado**: 2025-11-28
**Lineas**: 1400+
**Estado**: Listo para implementacion
**Siguiente documento**: 06-ROADMAP-SPRINTS.md
