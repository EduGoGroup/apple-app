# Plan de Implementacion: SPECs 009, 011, 012

**Proyecto:** EduGo Apple Multi-Platform App
**Fecha:** 2025-11-28
**Version:** 1.0
**SPECs Agrupadas:** Feature Flags (009), Analytics (011), Performance Monitoring (012)

---

## Tabla de Contenidos

1. [Resumen General](#resumen-general)
2. [SPEC-009: Feature Flags](#spec-009-feature-flags)
3. [SPEC-011: Analytics](#spec-011-analytics)
4. [SPEC-012: Performance Monitoring](#spec-012-performance-monitoring)
5. [Priorizacion Recomendada](#priorizacion-recomendada)
6. [Dependencias Entre SPECs](#dependencias-entre-specs)
7. [Timeline Consolidado](#timeline-consolidado)

---

## Resumen General

### Por Que Estan Agrupadas

Estas tres SPECs comparten:
1. **Prioridad similar:** P2-P3 (no criticas para MVP)
2. **Arquitectura comun:** Services con protocols, providers, y persistencia
3. **Dependencias:** 011 y 012 se benefician de 009
4. **Timeline:** Post-MVP, Sprint +2 y siguientes

### Vision Rapida

| SPEC | Nombre | Estado | Pendiente | Horas | Bloqueadores |
|------|--------|--------|-----------|-------|--------------|
| 009 | Feature Flags | 10% | 90% | 12h | Ninguno |
| 011 | Analytics | 5% | 95% | 14h | Firebase |
| 012 | Performance | 0% | 100% | 16h | SPEC-011 |
| **Total** | | | | **42h** | |

### Arquitectura Comun

```
┌─────────────────────────────────────────────────────────────┐
│                     Presentation Layer                       │
│  ┌─────────────┐  ┌─────────────┐  ┌────────────────────┐   │
│  │FeatureFlagUI│  │ AnalyticsUI │  │ PerformanceDashboard│   │
│  └──────┬──────┘  └──────┬──────┘  └─────────┬──────────┘   │
└─────────┼────────────────┼───────────────────┼──────────────┘
          │                │                   │
┌─────────┼────────────────┼───────────────────┼──────────────┐
│         │           Domain Layer             │              │
│  ┌──────▼──────┐  ┌──────▼──────┐  ┌────────▼────────┐     │
│  │FeatureFlagUC│  │AnalyticsUC  │  │PerformanceUC    │     │
│  └──────┬──────┘  └──────┬──────┘  └────────┬────────┘     │
└─────────┼────────────────┼───────────────────┼──────────────┘
          │                │                   │
┌─────────┼────────────────┼───────────────────┼──────────────┐
│         │            Data Layer              │              │
│  ┌──────▼──────┐  ┌──────▼──────┐  ┌────────▼────────┐     │
│  │FeatureFlagRepo│ │AnalyticsRepo│ │PerformanceRepo  │     │
│  └──────┬──────┘  └──────┬──────┘  └────────┬────────┘     │
│         │                │                   │              │
│  ┌──────▼──────┐  ┌──────▼──────┐  ┌────────▼────────┐     │
│  │LocalStorage │  │FirebaseProvider│ │MetricsCollector│     │
│  │RemoteConfig │  │MixpanelProvider│ │Instruments     │     │
│  └─────────────┘  └─────────────┘  └─────────────────┘     │
└─────────────────────────────────────────────────────────────┘
```

---

## SPEC-009: Feature Flags

### Estado Actual

- **Completitud:** 10%
- **Ubicacion Docs:** `docs/specs/feature-flags/`
- **Codigo Existente:** Solo flags compile-time en Environment.swift

### Arquitectura Propuesta

```
┌─────────────────────────────────────────────────────────────┐
│                     Feature Flag System                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌───────────────┐    ┌───────────────┐                    │
│   │  FeatureFlag  │    │FeatureFlagRepo│                    │
│   │    (Enum)     │◄───│   Protocol    │                    │
│   └───────────────┘    └───────┬───────┘                    │
│                                │                             │
│          ┌─────────────────────┼─────────────────────┐      │
│          │                     │                     │      │
│   ┌──────▼──────┐      ┌───────▼───────┐     ┌──────▼─────┐│
│   │LocalStorage │      │ RemoteConfig  │     │  Override  ││
│   │ (SwiftData) │      │   Service     │     │  (Debug)   ││
│   └─────────────┘      └───────────────┘     └────────────┘│
│                                                              │
└─────────────────────────────────────────────────────────────┘

Prioridad de evaluacion:
1. Override (Debug) - Para testing
2. Remote Config - Del servidor
3. Local Storage - Cache persistente
4. Default Value - Valor por defecto en enum
```

### Fases de Implementacion

#### Fase 1: FeatureFlag Enum y Protocol (1h)

**Crear:** `/Domain/Entities/FeatureFlag.swift`

```swift
import Foundation

/// Feature flags disponibles en la aplicacion
///
/// Cada flag tiene un valor por defecto que se usa cuando no hay
/// override local ni remoto.
enum FeatureFlag: String, CaseIterable, Codable, Sendable {

    // MARK: - Authentication

    /// Habilita login con biometrics (Face ID / Touch ID)
    case biometricLogin

    /// Habilita recordar email en login
    case rememberEmail

    // MARK: - UI Features

    /// Nueva UI de home (experimento)
    case newHomeUI

    /// Tema oscuro automatico segun hora
    case autoDarkMode

    /// Animaciones avanzadas
    case enhancedAnimations

    // MARK: - Offline

    /// Modo offline completo
    case offlineMode

    /// Sincronizacion en background
    case backgroundSync

    // MARK: - Analytics

    /// Habilita tracking de analytics
    case analyticsEnabled

    /// Habilita crash reporting
    case crashReportingEnabled

    // MARK: - Experimental

    /// Features experimentales (solo desarrollo)
    case experimentalFeatures

    // MARK: - Default Values

    /// Valor por defecto cuando no hay override
    var defaultValue: Bool {
        switch self {
        case .biometricLogin:
            return true
        case .rememberEmail:
            return true
        case .newHomeUI:
            return false  // Experimento deshabilitado por defecto
        case .autoDarkMode:
            return false
        case .enhancedAnimations:
            return true
        case .offlineMode:
            return true
        case .backgroundSync:
            return true
        case .analyticsEnabled:
            return AppEnvironment.current == .production
        case .crashReportingEnabled:
            return AppEnvironment.current == .production
        case .experimentalFeatures:
            return AppEnvironment.current == .development
        }
    }

    /// Descripcion para UI de administracion
    var displayName: String {
        switch self {
        case .biometricLogin: return "Login Biometrico"
        case .rememberEmail: return "Recordar Email"
        case .newHomeUI: return "Nueva UI Home"
        case .autoDarkMode: return "Tema Oscuro Automatico"
        case .enhancedAnimations: return "Animaciones Avanzadas"
        case .offlineMode: return "Modo Offline"
        case .backgroundSync: return "Sincronizacion en Background"
        case .analyticsEnabled: return "Analytics"
        case .crashReportingEnabled: return "Crash Reporting"
        case .experimentalFeatures: return "Features Experimentales"
        }
    }

    /// Categoria del flag para agrupacion en UI
    var category: FeatureFlagCategory {
        switch self {
        case .biometricLogin, .rememberEmail:
            return .authentication
        case .newHomeUI, .autoDarkMode, .enhancedAnimations:
            return .ui
        case .offlineMode, .backgroundSync:
            return .offline
        case .analyticsEnabled, .crashReportingEnabled:
            return .analytics
        case .experimentalFeatures:
            return .experimental
        }
    }
}

enum FeatureFlagCategory: String, CaseIterable {
    case authentication = "Autenticacion"
    case ui = "Interfaz"
    case offline = "Offline"
    case analytics = "Analytics"
    case experimental = "Experimental"
}
```

**Crear:** `/Domain/Repositories/FeatureFlagRepository.swift`

```swift
import Foundation

/// Repositorio para gestionar feature flags
///
/// Implementa patron de evaluacion:
/// 1. Override local (debug)
/// 2. Remote config
/// 3. Cache local
/// 4. Default value
protocol FeatureFlagRepository: Sendable {

    /// Verifica si un flag esta habilitado
    /// - Parameter flag: El flag a verificar
    /// - Returns: true si habilitado
    func isEnabled(_ flag: FeatureFlag) async -> Bool

    /// Obtiene todos los flags con su estado actual
    /// - Returns: Diccionario de flags y valores
    func getAllFlags() async -> [FeatureFlag: Bool]

    /// Establece override local (solo desarrollo)
    /// - Parameters:
    ///   - flag: Flag a override
    ///   - value: Valor a establecer, nil para quitar override
    func setOverride(_ flag: FeatureFlag, value: Bool?) async

    /// Sincroniza con remote config
    /// - Returns: true si hubo cambios
    @discardableResult
    func syncRemoteFlags() async throws -> Bool

    /// Observa cambios en un flag
    /// - Parameter flag: Flag a observar
    /// - Returns: AsyncStream de valores
    func observe(_ flag: FeatureFlag) -> AsyncStream<Bool>
}
```

#### Fase 2: Implementacion Local (2h)

**Crear:** `/Data/Repositories/FeatureFlagRepositoryImpl.swift`

```swift
import Foundation
import SwiftData

/// Implementacion de FeatureFlagRepository
///
/// Usa SwiftData para persistencia local y soporta
/// remote config cuando este disponible.
actor FeatureFlagRepositoryImpl: FeatureFlagRepository {

    // MARK: - Dependencies

    private let modelContext: ModelContext?
    private let remoteConfigService: RemoteConfigService?
    private let logger = LoggerFactory.featureFlags

    // MARK: - State

    /// Cache en memoria para acceso rapido
    private var cache: [FeatureFlag: Bool] = [:]

    /// Overrides locales (desarrollo)
    private var overrides: [FeatureFlag: Bool] = [:]

    /// Continuations para observers
    private var continuations: [FeatureFlag: [AsyncStream<Bool>.Continuation]] = [:]

    // MARK: - Initialization

    init(
        modelContext: ModelContext? = nil,
        remoteConfigService: RemoteConfigService? = nil
    ) {
        self.modelContext = modelContext
        self.remoteConfigService = remoteConfigService

        Task {
            await loadCachedFlags()
        }
    }

    // MARK: - FeatureFlagRepository

    func isEnabled(_ flag: FeatureFlag) async -> Bool {
        // 1. Override local (desarrollo)
        if let override = overrides[flag] {
            return override
        }

        // 2. Cache (incluye remote si sincronizado)
        if let cached = cache[flag] {
            return cached
        }

        // 3. Default value
        return flag.defaultValue
    }

    func getAllFlags() async -> [FeatureFlag: Bool] {
        var result: [FeatureFlag: Bool] = [:]

        for flag in FeatureFlag.allCases {
            result[flag] = await isEnabled(flag)
        }

        return result
    }

    func setOverride(_ flag: FeatureFlag, value: Bool?) async {
        if let value = value {
            overrides[flag] = value
            logger.info("Override set: \(flag.rawValue) = \(value)")
        } else {
            overrides.removeValue(forKey: flag)
            logger.info("Override removed: \(flag.rawValue)")
        }

        // Notificar observers
        notifyObservers(flag: flag, value: await isEnabled(flag))
    }

    func syncRemoteFlags() async throws -> Bool {
        guard let remoteService = remoteConfigService else {
            logger.debug("No remote config service configured")
            return false
        }

        do {
            let remoteFlags = try await remoteService.fetchFlags()
            var hasChanges = false

            for (flag, value) in remoteFlags {
                if cache[flag] != value {
                    cache[flag] = value
                    hasChanges = true
                    notifyObservers(flag: flag, value: value)
                }
            }

            // Persistir en SwiftData
            await persistFlags()

            logger.info("Remote flags synced, changes: \(hasChanges)")
            return hasChanges

        } catch {
            logger.error("Failed to sync remote flags: \(error)")
            throw error
        }
    }

    func observe(_ flag: FeatureFlag) -> AsyncStream<Bool> {
        AsyncStream { continuation in
            // Agregar continuation a lista
            if continuations[flag] == nil {
                continuations[flag] = []
            }
            continuations[flag]?.append(continuation)

            // Enviar valor inicial
            Task {
                let currentValue = await isEnabled(flag)
                continuation.yield(currentValue)
            }

            // Cleanup al terminar
            continuation.onTermination = { [weak self] _ in
                Task {
                    await self?.removeObserver(for: flag, continuation: continuation)
                }
            }
        }
    }

    // MARK: - Private Methods

    private func loadCachedFlags() {
        guard let context = modelContext else { return }

        do {
            let descriptor = FetchDescriptor<CachedFeatureFlag>()
            let cached = try context.fetch(descriptor)

            for item in cached {
                if let flag = FeatureFlag(rawValue: item.key) {
                    cache[flag] = item.value
                }
            }

            logger.debug("Loaded \(cached.count) cached flags")
        } catch {
            logger.error("Failed to load cached flags: \(error)")
        }
    }

    private func persistFlags() async {
        guard let context = modelContext else { return }

        do {
            // Eliminar cache anterior
            try context.delete(model: CachedFeatureFlag.self)

            // Guardar cache actual
            for (flag, value) in cache {
                let cached = CachedFeatureFlag(key: flag.rawValue, value: value)
                context.insert(cached)
            }

            try context.save()
            logger.debug("Persisted \(cache.count) flags")
        } catch {
            logger.error("Failed to persist flags: \(error)")
        }
    }

    private func notifyObservers(flag: FeatureFlag, value: Bool) {
        guard let observers = continuations[flag] else { return }

        for continuation in observers {
            continuation.yield(value)
        }
    }

    private func removeObserver(for flag: FeatureFlag, continuation: AsyncStream<Bool>.Continuation) {
        continuations[flag]?.removeAll { $0 === continuation }
    }
}

// MARK: - SwiftData Model

@Model
final class CachedFeatureFlag {
    @Attribute(.unique) var key: String
    var value: Bool
    var updatedAt: Date

    init(key: String, value: Bool) {
        self.key = key
        self.value = value
        self.updatedAt = Date()
    }
}
```

#### Fase 3: Remote Config Service (3h)

**Crear:** `/Data/Services/Config/RemoteConfigService.swift`

```swift
import Foundation

/// Protocolo para servicio de configuracion remota
protocol RemoteConfigService: Sendable {

    /// Obtiene flags desde servidor
    /// - Returns: Diccionario de flags
    func fetchFlags() async throws -> [FeatureFlag: Bool]

    /// TTL de cache en segundos
    var cacheTTL: TimeInterval { get }
}

/// Implementacion usando endpoint propio del backend
final class EduGoRemoteConfigService: RemoteConfigService, Sendable {

    private let apiClient: APIClient
    private let logger = LoggerFactory.config

    var cacheTTL: TimeInterval { 3600 }  // 1 hora

    init(apiClient: APIClient) {
        self.apiClient = apiClient
    }

    func fetchFlags() async throws -> [FeatureFlag: Bool] {
        let endpoint = Endpoint(
            path: "/config/flags",
            method: .get
        )

        let response: RemoteFlagsResponse = try await apiClient.execute(endpoint)

        var flags: [FeatureFlag: Bool] = [:]
        for (key, value) in response.flags {
            if let flag = FeatureFlag(rawValue: key) {
                flags[flag] = value
            }
        }

        return flags
    }
}

// MARK: - DTO

struct RemoteFlagsResponse: Decodable {
    let flags: [String: Bool]
    let version: String
    let ttl: Int?
}
```

#### Fase 4: A/B Testing Support (2h)

**Crear:** `/Domain/Entities/ABTest.swift`

```swift
import Foundation

/// Representa un experimento A/B
struct ABTest: Identifiable, Codable, Sendable {
    let id: String
    let name: String
    let variants: [Variant]
    let allocation: [String: Double]  // variant_id -> porcentaje

    struct Variant: Codable, Sendable {
        let id: String
        let name: String
        let config: [String: AnyCodable]
    }
}

/// Extension de FeatureFlagRepository para A/B testing
extension FeatureFlagRepository {

    /// Obtiene la variante asignada al usuario para un experimento
    func getVariant(for testId: String) async -> ABTest.Variant?
}
```

#### Fase 5: Admin UI (1h)

**Crear:** `/Presentation/Scenes/Debug/FeatureFlagsDebugView.swift`

```swift
import SwiftUI

/// Vista de debug para administrar feature flags
///
/// Solo disponible en builds de desarrollo
struct FeatureFlagsDebugView: View {

    @State private var flags: [FeatureFlag: Bool] = [:]
    @State private var overrides: [FeatureFlag: Bool?] = [:]

    private let repository: FeatureFlagRepository

    init(repository: FeatureFlagRepository) {
        self.repository = repository
    }

    var body: some View {
        List {
            ForEach(FeatureFlagCategory.allCases, id: \.self) { category in
                Section(header: Text(category.rawValue)) {
                    ForEach(flagsForCategory(category), id: \.self) { flag in
                        FlagRow(
                            flag: flag,
                            isEnabled: flags[flag] ?? flag.defaultValue,
                            hasOverride: overrides[flag] != nil,
                            onToggle: { newValue in
                                Task {
                                    await toggleFlag(flag, value: newValue)
                                }
                            },
                            onClearOverride: {
                                Task {
                                    await clearOverride(flag)
                                }
                            }
                        )
                    }
                }
            }
        }
        .navigationTitle("Feature Flags")
        .task {
            await loadFlags()
        }
        .refreshable {
            try? await repository.syncRemoteFlags()
            await loadFlags()
        }
    }

    private func flagsForCategory(_ category: FeatureFlagCategory) -> [FeatureFlag] {
        FeatureFlag.allCases.filter { $0.category == category }
    }

    private func loadFlags() async {
        flags = await repository.getAllFlags()
    }

    private func toggleFlag(_ flag: FeatureFlag, value: Bool) async {
        await repository.setOverride(flag, value: value)
        overrides[flag] = value
        flags[flag] = value
    }

    private func clearOverride(_ flag: FeatureFlag) async {
        await repository.setOverride(flag, value: nil)
        overrides[flag] = nil
        await loadFlags()
    }
}

struct FlagRow: View {
    let flag: FeatureFlag
    let isEnabled: Bool
    let hasOverride: Bool
    let onToggle: (Bool) -> Void
    let onClearOverride: () -> Void

    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text(flag.displayName)
                    .font(.body)
                Text(flag.rawValue)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            Spacer()

            if hasOverride {
                Button("Reset") {
                    onClearOverride()
                }
                .font(.caption)
            }

            Toggle("", isOn: Binding(
                get: { isEnabled },
                set: { onToggle($0) }
            ))
        }
    }
}
```

### Criterios de Aceptacion SPEC-009

- [ ] FeatureFlag enum con 10+ flags
- [ ] FeatureFlagRepository protocol
- [ ] Implementacion con SwiftData
- [ ] Remote config service (opcional)
- [ ] A/B testing basico
- [ ] Debug UI funcional
- [ ] Tests (8+)
- [ ] Documentacion

**Estimacion Total:** 12 horas

---

## SPEC-011: Analytics

### Estado Actual

- **Completitud:** 5%
- **Ubicacion Docs:** `docs/specs/analytics/`
- **Codigo Existente:** Solo `analyticsEnabled` flag

### Arquitectura Propuesta

```
┌─────────────────────────────────────────────────────────────┐
│                     Analytics System                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌───────────────┐    ┌───────────────┐                    │
│   │AnalyticsEvent │    │AnalyticsService│                   │
│   │    (Enum)     │◄───│   Protocol    │                    │
│   └───────────────┘    └───────┬───────┘                    │
│                                │                             │
│          ┌─────────────────────┼─────────────────────┐      │
│          │                     │                     │      │
│   ┌──────▼──────┐      ┌───────▼───────┐     ┌──────▼─────┐│
│   │  Firebase   │      │   Mixpanel    │     │   Local    ││
│   │  Provider   │      │   Provider    │     │   Logger   ││
│   └─────────────┘      └───────────────┘     └────────────┘│
│                                                              │
│   ┌─────────────────────────────────────────────────────┐   │
│   │              User Consent Manager                    │   │
│   │  ┌─────────┐  ┌──────────┐  ┌─────────────────┐     │   │
│   │  │Consent UI│  │Preferences│  │GDPR Compliance │     │   │
│   │  └─────────┘  └──────────┘  └─────────────────┘     │   │
│   └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### Fases de Implementacion

#### Fase 1: AnalyticsService Protocol (1h)

**Crear:** `/Domain/Services/AnalyticsService.swift`

```swift
import Foundation

/// Protocolo para servicios de analytics
///
/// Soporta multiples providers (Firebase, Mixpanel, etc)
/// con sanitizacion automatica y consent management.
protocol AnalyticsService: Sendable {

    /// Registra un evento
    /// - Parameters:
    ///   - event: Evento a registrar
    ///   - properties: Propiedades adicionales
    func track(event: AnalyticsEvent, properties: [String: Any]?)

    /// Identifica al usuario
    /// - Parameter userId: ID del usuario
    func identify(userId: String)

    /// Establece propiedades del usuario
    /// - Parameter properties: Propiedades a establecer
    func setUserProperties(_ properties: [String: Any])

    /// Registra inicio de pantalla
    /// - Parameter screenName: Nombre de la pantalla
    func trackScreenView(_ screenName: String)

    /// Limpia datos del usuario (logout)
    func reset()

    /// Indica si analytics esta habilitado
    var isEnabled: Bool { get }
}
```

**Crear:** `/Domain/Entities/AnalyticsEvent.swift`

```swift
import Foundation

/// Catalogo de eventos de analytics
///
/// Cada evento tiene un nombre, categoria y propiedades requeridas/opcionales.
enum AnalyticsEvent: String, Sendable {

    // MARK: - Authentication

    case login = "user_login"
    case loginFailed = "user_login_failed"
    case logout = "user_logout"
    case signUp = "user_sign_up"
    case passwordReset = "user_password_reset"

    // MARK: - Navigation

    case screenView = "screen_view"
    case buttonTap = "button_tap"
    case tabChange = "tab_change"

    // MARK: - Content

    case contentView = "content_view"
    case contentShare = "content_share"
    case contentDownload = "content_download"

    // MARK: - Errors

    case errorOccurred = "error_occurred"
    case networkError = "network_error"
    case appCrash = "app_crash"

    // MARK: - Settings

    case settingsChanged = "settings_changed"
    case themeChanged = "theme_changed"
    case languageChanged = "language_changed"

    // MARK: - Performance

    case appLaunch = "app_launch"
    case screenRender = "screen_render"

    // MARK: - Properties

    /// Categoria del evento
    var category: String {
        switch self {
        case .login, .loginFailed, .logout, .signUp, .passwordReset:
            return "authentication"
        case .screenView, .buttonTap, .tabChange:
            return "navigation"
        case .contentView, .contentShare, .contentDownload:
            return "content"
        case .errorOccurred, .networkError, .appCrash:
            return "error"
        case .settingsChanged, .themeChanged, .languageChanged:
            return "settings"
        case .appLaunch, .screenRender:
            return "performance"
        }
    }

    /// Propiedades requeridas para el evento
    var requiredProperties: [String] {
        switch self {
        case .screenView:
            return ["screen_name"]
        case .buttonTap:
            return ["button_name"]
        case .errorOccurred:
            return ["error_type", "error_message"]
        default:
            return []
        }
    }
}
```

#### Fase 2: AnalyticsManager (2h)

**Crear:** `/Data/Services/Analytics/AnalyticsManager.swift`

```swift
import Foundation

/// Manager central de analytics
///
/// Coordina multiples providers y aplica:
/// - Consent verification
/// - Property sanitization
/// - Batching (opcional)
@MainActor
final class AnalyticsManager: AnalyticsService {

    // MARK: - Dependencies

    private var providers: [AnalyticsProvider]
    private let consentManager: UserConsentManager
    private let logger = LoggerFactory.analytics

    // MARK: - State

    private(set) var isEnabled: Bool

    // MARK: - Initialization

    init(
        providers: [AnalyticsProvider] = [],
        consentManager: UserConsentManager
    ) {
        self.providers = providers
        self.consentManager = consentManager
        self.isEnabled = consentManager.hasAnalyticsConsent
    }

    // MARK: - AnalyticsService

    func track(event: AnalyticsEvent, properties: [String: Any]?) {
        guard isEnabled && consentManager.hasAnalyticsConsent else {
            logger.debug("Analytics disabled, skipping event: \(event.rawValue)")
            return
        }

        let sanitized = sanitizeProperties(properties)
        let enriched = enrichProperties(sanitized, for: event)

        logger.debug("Tracking event: \(event.rawValue)")

        for provider in providers {
            provider.track(event: event.rawValue, properties: enriched)
        }
    }

    func identify(userId: String) {
        guard isEnabled && consentManager.hasAnalyticsConsent else { return }

        // Hash user ID for privacy
        let hashedId = hashUserId(userId)

        for provider in providers {
            provider.identify(userId: hashedId)
        }
    }

    func setUserProperties(_ properties: [String: Any]) {
        guard isEnabled && consentManager.hasAnalyticsConsent else { return }

        let sanitized = sanitizeUserProperties(properties)

        for provider in providers {
            provider.setUserProperties(sanitized)
        }
    }

    func trackScreenView(_ screenName: String) {
        track(event: .screenView, properties: ["screen_name": screenName])
    }

    func reset() {
        for provider in providers {
            provider.reset()
        }
    }

    // MARK: - Provider Management

    func addProvider(_ provider: AnalyticsProvider) {
        providers.append(provider)
    }

    func removeProvider(_ type: AnalyticsProvider.Type) {
        providers.removeAll { Swift.type(of: $0) == type }
    }

    // MARK: - Private Methods

    private func sanitizeProperties(_ properties: [String: Any]?) -> [String: Any] {
        guard var props = properties else { return [:] }

        // Remover PII
        let piiKeys = ["email", "phone", "name", "password", "credit_card"]
        for key in piiKeys {
            props.removeValue(forKey: key)
        }

        // Truncar strings largos
        for (key, value) in props {
            if let string = value as? String, string.count > 100 {
                props[key] = String(string.prefix(100))
            }
        }

        return props
    }

    private func enrichProperties(_ properties: [String: Any], for event: AnalyticsEvent) -> [String: Any] {
        var enriched = properties

        // Agregar metadata comun
        enriched["event_category"] = event.category
        enriched["timestamp"] = ISO8601DateFormatter().string(from: Date())
        enriched["app_version"] = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String
        enriched["platform"] = "iOS"

        return enriched
    }

    private func sanitizeUserProperties(_ properties: [String: Any]) -> [String: Any] {
        var sanitized = properties

        // Remover datos sensibles
        sanitized.removeValue(forKey: "email")
        sanitized.removeValue(forKey: "name")

        return sanitized
    }

    private func hashUserId(_ userId: String) -> String {
        // SHA256 hash del user ID
        let data = Data(userId.utf8)
        // Usar CryptoKit en implementacion real
        return data.base64EncodedString()
    }
}

/// Protocolo base para providers de analytics
protocol AnalyticsProvider: Sendable {
    func track(event: String, properties: [String: Any])
    func identify(userId: String)
    func setUserProperties(_ properties: [String: Any])
    func reset()
}
```

#### Fase 3: Firebase Provider (3h)

**Crear:** `/Data/Services/Analytics/FirebaseAnalyticsProvider.swift`

```swift
import Foundation
// import FirebaseAnalytics  // Descomentar cuando se agregue Firebase

/// Provider de Firebase Analytics
final class FirebaseAnalyticsProvider: AnalyticsProvider, @unchecked Sendable {

    private let logger = LoggerFactory.analytics

    init() {
        // Firebase se configura automaticamente con GoogleService-Info.plist
        logger.info("Firebase Analytics provider initialized")
    }

    func track(event: String, properties: [String: Any]) {
        // Analytics.logEvent(event, parameters: properties)
        logger.debug("Firebase: \(event)")
    }

    func identify(userId: String) {
        // Analytics.setUserID(userId)
    }

    func setUserProperties(_ properties: [String: Any]) {
        for (key, value) in properties {
            // Analytics.setUserProperty(String(describing: value), forName: key)
        }
    }

    func reset() {
        // Analytics.setUserID(nil)
    }
}
```

#### Fase 4: Privacy Compliance (1.5h)

**Crear:** `/Data/Services/Analytics/UserConsentManager.swift`

```swift
import Foundation

/// Manager de consentimiento de usuario para analytics
///
/// Cumple con GDPR y App Tracking Transparency.
actor UserConsentManager {

    // MARK: - Types

    enum ConsentType: String, CaseIterable {
        case analytics
        case crashReporting
        case personalization
        case marketing
    }

    // MARK: - State

    private var consents: [ConsentType: Bool] = [:]
    private let userDefaults = UserDefaults.standard
    private let logger = LoggerFactory.analytics

    // MARK: - Public Properties

    var hasAnalyticsConsent: Bool {
        consents[.analytics] ?? false
    }

    var hasCrashReportingConsent: Bool {
        consents[.crashReporting] ?? false
    }

    // MARK: - Initialization

    init() {
        loadConsents()
    }

    // MARK: - Public Methods

    /// Establece consentimiento para un tipo
    func setConsent(_ type: ConsentType, granted: Bool) {
        consents[type] = granted
        saveConsents()

        logger.info("Consent \(type.rawValue): \(granted)")
    }

    /// Verifica si tiene consentimiento
    func hasConsent(for type: ConsentType) -> Bool {
        consents[type] ?? false
    }

    /// Obtiene todos los consentimientos
    func getAllConsents() -> [ConsentType: Bool] {
        consents
    }

    /// Revoca todos los consentimientos
    func revokeAllConsents() {
        for type in ConsentType.allCases {
            consents[type] = false
        }
        saveConsents()
        logger.info("All consents revoked")
    }

    // MARK: - Private Methods

    private func loadConsents() {
        for type in ConsentType.allCases {
            let key = "consent_\(type.rawValue)"
            consents[type] = userDefaults.bool(forKey: key)
        }
    }

    private func saveConsents() {
        for (type, granted) in consents {
            let key = "consent_\(type.rawValue)"
            userDefaults.set(granted, forKey: key)
        }
    }
}
```

#### Fase 5: Consent UI (1.5h)

**Crear:** `/Presentation/Scenes/Consent/ConsentView.swift`

```swift
import SwiftUI

/// Vista para solicitar consentimiento de analytics
struct ConsentView: View {

    @State private var analyticsConsent = false
    @State private var crashConsent = false

    let consentManager: UserConsentManager
    let onComplete: () -> Void

    var body: some View {
        VStack(spacing: DSSpacing.large) {
            // Header
            VStack(spacing: DSSpacing.medium) {
                Image(systemName: "chart.bar.doc.horizontal")
                    .font(.system(size: 60))
                    .foregroundColor(DSColors.accent)

                Text("Ayudanos a mejorar")
                    .font(DSTypography.title)

                Text("Recopilamos datos anonimos para mejorar la experiencia de la app.")
                    .font(DSTypography.body)
                    .multilineTextAlignment(.center)
                    .foregroundColor(DSColors.textSecondary)
            }

            // Consent options
            VStack(spacing: DSSpacing.medium) {
                ConsentRow(
                    title: "Analytics",
                    description: "Datos de uso anonimos",
                    isEnabled: $analyticsConsent
                )

                ConsentRow(
                    title: "Reportes de errores",
                    description: "Ayuda a detectar problemas",
                    isEnabled: $crashConsent
                )
            }
            .padding()
            .background(DSColors.surface)
            .cornerRadius(DSCornerRadius.medium)

            Spacer()

            // Buttons
            VStack(spacing: DSSpacing.small) {
                DSButton(title: "Aceptar seleccionados", style: .primary) {
                    saveConsents()
                }

                DSButton(title: "Rechazar todo", style: .secondary) {
                    rejectAll()
                }
            }

            // Privacy policy link
            Button("Ver politica de privacidad") {
                // Abrir URL de privacy policy
            }
            .font(.caption)
        }
        .padding()
    }

    private func saveConsents() {
        Task {
            await consentManager.setConsent(.analytics, granted: analyticsConsent)
            await consentManager.setConsent(.crashReporting, granted: crashConsent)
            onComplete()
        }
    }

    private func rejectAll() {
        Task {
            await consentManager.revokeAllConsents()
            onComplete()
        }
    }
}

struct ConsentRow: View {
    let title: String
    let description: String
    @Binding var isEnabled: Bool

    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text(title)
                    .font(DSTypography.bodyBold)
                Text(description)
                    .font(DSTypography.caption)
                    .foregroundColor(DSColors.textSecondary)
            }
            Spacer()
            Toggle("", isOn: $isEnabled)
        }
    }
}
```

### Criterios de Aceptacion SPEC-011

- [ ] AnalyticsService protocol
- [ ] AnalyticsEvent enum (15+ eventos)
- [ ] AnalyticsManager multi-provider
- [ ] Firebase provider (cuando disponible)
- [ ] UserConsentManager
- [ ] Consent UI
- [ ] Tests (6+)
- [ ] Documentacion

**Estimacion Total:** 14 horas

---

## SPEC-012: Performance Monitoring

### Estado Actual

- **Completitud:** 0%
- **Ubicacion Docs:** `docs/specs/performance-monitoring/`
- **Codigo Existente:** Ninguno

### Arquitectura Propuesta

```
┌─────────────────────────────────────────────────────────────┐
│                  Performance Monitoring System               │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌───────────────┐    ┌───────────────┐                    │
│   │PerformanceMetric│   │PerformanceMonitor│                │
│   │    (Struct)   │◄───│     (Actor)    │                   │
│   └───────────────┘    └───────┬───────┘                    │
│                                │                             │
│          ┌─────────────────────┼─────────────────────┐      │
│          │                     │                     │      │
│   ┌──────▼──────┐      ┌───────▼───────┐     ┌──────▼─────┐│
│   │Launch Time  │      │Screen Render  │     │  Network   ││
│   │  Tracker    │      │   Tracker     │     │  Tracker   ││
│   └─────────────┘      └───────────────┘     └────────────┘│
│                                                              │
│   ┌─────────────────────────────────────────────────────┐   │
│   │                Memory Monitor                        │   │
│   │  ┌─────────┐  ┌──────────┐  ┌─────────────────┐     │   │
│   │  │ Memory  │  │  Leaks   │  │   Frame Rate    │     │   │
│   │  │ Usage   │  │ Detection│  │   Tracking      │     │   │
│   │  └─────────┘  └──────────┘  └─────────────────┘     │   │
│   └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### Fases de Implementacion

#### Fase 1: PerformanceMonitor Actor (2h)

**Crear:** `/Core/Performance/PerformanceMonitor.swift`

```swift
import Foundation
import os.signpost

/// Monitor central de performance de la aplicacion
///
/// Recopila metricas de:
/// - Tiempo de lanzamiento
/// - Render de pantallas
/// - Requests de red
/// - Uso de memoria
actor PerformanceMonitor {

    // MARK: - Singleton

    static let shared = PerformanceMonitor()

    // MARK: - Dependencies

    private let logger = LoggerFactory.performance
    private let signposter = OSSignposter(subsystem: "com.edugo.app", category: "Performance")

    // MARK: - State

    private var metrics: [String: PerformanceMetric] = [:]
    private var appLaunchStart: Date?
    private var isMonitoringEnabled = true

    // MARK: - Configuration

    /// Umbral de alerta para tiempo de lanzamiento (segundos)
    let launchTimeThreshold: TimeInterval = 3.0

    /// Umbral de alerta para render de pantalla (segundos)
    let screenRenderThreshold: TimeInterval = 0.5

    /// Umbral de alerta para requests de red (segundos)
    let networkRequestThreshold: TimeInterval = 5.0

    // MARK: - Public Methods

    /// Registra inicio de lanzamiento de app
    func markAppLaunchStart() {
        appLaunchStart = Date()
        logger.debug("App launch started")
    }

    /// Registra fin de lanzamiento de app
    func markAppLaunchEnd() {
        guard let start = appLaunchStart else { return }

        let duration = Date().timeIntervalSince(start)
        let metric = PerformanceMetric(
            name: "app_launch",
            duration: duration,
            timestamp: Date(),
            metadata: ["cold_start": "true"]
        )

        record(metric)

        if duration > launchTimeThreshold {
            logger.warning("Slow app launch: \(String(format: "%.2f", duration))s")
        } else {
            logger.info("App launch: \(String(format: "%.2f", duration))s")
        }

        appLaunchStart = nil
    }

    /// Inicia medicion de render de pantalla
    /// - Parameter screenName: Nombre de la pantalla
    /// - Returns: ID de signpost para terminar medicion
    func startScreenRender(_ screenName: String) -> OSSignpostID {
        let signpostID = signposter.makeSignpostID()
        signposter.beginInterval("ScreenRender", id: signpostID, "\(screenName)")
        return signpostID
    }

    /// Termina medicion de render de pantalla
    func endScreenRender(_ screenName: String, signpostID: OSSignpostID, renderTime: TimeInterval) {
        signposter.endInterval("ScreenRender", signpostID)

        let metric = PerformanceMetric(
            name: "screen_render",
            duration: renderTime,
            timestamp: Date(),
            metadata: ["screen_name": screenName]
        )

        record(metric)

        if renderTime > screenRenderThreshold {
            logger.warning("Slow screen render: \(screenName) = \(String(format: "%.2f", renderTime))s")
        }
    }

    /// Registra tiempo de request de red
    func recordNetworkRequest(
        endpoint: String,
        duration: TimeInterval,
        statusCode: Int,
        responseSize: Int
    ) {
        let metric = PerformanceMetric(
            name: "network_request",
            duration: duration,
            timestamp: Date(),
            metadata: [
                "endpoint": endpoint,
                "status_code": String(statusCode),
                "response_size": String(responseSize)
            ]
        )

        record(metric)

        if duration > networkRequestThreshold {
            logger.warning("Slow network request: \(endpoint) = \(String(format: "%.2f", duration))s")
        }
    }

    /// Obtiene metricas recientes
    func getRecentMetrics(limit: Int = 100) -> [PerformanceMetric] {
        Array(metrics.values.sorted { $0.timestamp > $1.timestamp }.prefix(limit))
    }

    /// Obtiene estadisticas agregadas
    func getStats() -> PerformanceStats {
        let appLaunches = metrics.values.filter { $0.name == "app_launch" }
        let screenRenders = metrics.values.filter { $0.name == "screen_render" }
        let networkRequests = metrics.values.filter { $0.name == "network_request" }

        return PerformanceStats(
            averageLaunchTime: average(appLaunches.map(\.duration)),
            averageScreenRender: average(screenRenders.map(\.duration)),
            averageNetworkRequest: average(networkRequests.map(\.duration)),
            totalMetrics: metrics.count
        )
    }

    // MARK: - Private Methods

    private func record(_ metric: PerformanceMetric) {
        let key = "\(metric.name)_\(metric.timestamp.timeIntervalSince1970)"
        metrics[key] = metric

        // Limpiar metricas antiguas (mas de 1 hora)
        let cutoff = Date().addingTimeInterval(-3600)
        metrics = metrics.filter { $0.value.timestamp > cutoff }
    }

    private func average(_ values: [TimeInterval]) -> TimeInterval {
        guard !values.isEmpty else { return 0 }
        return values.reduce(0, +) / Double(values.count)
    }
}

// MARK: - Supporting Types

struct PerformanceMetric: Sendable {
    let name: String
    let duration: TimeInterval
    let timestamp: Date
    let metadata: [String: String]
}

struct PerformanceStats: Sendable {
    let averageLaunchTime: TimeInterval
    let averageScreenRender: TimeInterval
    let averageNetworkRequest: TimeInterval
    let totalMetrics: Int
}
```

#### Fase 2: Launch Time Tracking (2h)

**Crear:** `/Core/Performance/LaunchTimeTracker.swift`

```swift
import Foundation

/// Tracker de tiempo de lanzamiento de la app
///
/// Mide tiempo desde main() hasta que la app esta interactiva.
enum LaunchTimeTracker {

    // MARK: - State

    private static var processStartTime: Date?
    private static var preMainTime: Date?

    // MARK: - Public Methods

    /// Llamar lo antes posible en main()
    static func markProcessStart() {
        processStartTime = Date()
    }

    /// Llamar en AppDelegate.didFinishLaunching
    static func markPreMain() {
        preMainTime = Date()
    }

    /// Llamar cuando la UI esta lista para interaccion
    static func markAppReady() {
        Task {
            await PerformanceMonitor.shared.markAppLaunchEnd()
        }
    }

    /// Obtiene metricas detalladas de lanzamiento
    static func getLaunchMetrics() -> LaunchMetrics {
        let now = Date()
        let preMainDuration = preMainTime.map { now.timeIntervalSince($0) } ?? 0
        let totalDuration = processStartTime.map { now.timeIntervalSince($0) } ?? 0

        return LaunchMetrics(
            preMainTime: preMainDuration,
            postMainTime: totalDuration - preMainDuration,
            totalTime: totalDuration
        )
    }
}

struct LaunchMetrics: Sendable {
    let preMainTime: TimeInterval
    let postMainTime: TimeInterval
    let totalTime: TimeInterval
}
```

#### Fase 3: Screen Render Tracking (3h)

**Crear:** `/Core/Performance/ScreenRenderTracker.swift`

```swift
import SwiftUI
import os.signpost

/// ViewModifier para tracking de render de pantallas
struct PerformanceTrackingModifier: ViewModifier {

    let screenName: String
    @State private var renderStart: Date?
    @State private var signpostID: OSSignpostID?

    func body(content: Content) -> some View {
        content
            .onAppear {
                startTracking()
            }
            .task {
                // Dar tiempo al render inicial
                try? await Task.sleep(nanoseconds: 100_000_000) // 100ms
                await endTracking()
            }
    }

    private func startTracking() {
        renderStart = Date()
        Task {
            signpostID = await PerformanceMonitor.shared.startScreenRender(screenName)
        }
    }

    private func endTracking() async {
        guard let start = renderStart, let id = signpostID else { return }

        let duration = Date().timeIntervalSince(start)
        await PerformanceMonitor.shared.endScreenRender(screenName, signpostID: id, renderTime: duration)
    }
}

extension View {
    /// Agrega tracking de performance a una vista
    /// - Parameter screenName: Nombre de la pantalla para metricas
    func trackPerformance(screenName: String) -> some View {
        modifier(PerformanceTrackingModifier(screenName: screenName))
    }
}
```

#### Fase 4: Network Performance (2h)

Integrado con APIClient existente.

**Modificar:** `/Data/Network/APIClient.swift`

```swift
// En el metodo execute:
func execute<T: Decodable>(_ endpoint: Endpoint) async throws -> T {
    let startTime = Date()

    // ... codigo existente de request ...

    let duration = Date().timeIntervalSince(startTime)
    let responseSize = data.count

    // Registrar metrica
    Task {
        await PerformanceMonitor.shared.recordNetworkRequest(
            endpoint: endpoint.path,
            duration: duration,
            statusCode: response.statusCode,
            responseSize: responseSize
        )
    }

    return decoded
}
```

#### Fase 5: Memory Monitoring (2h)

**Crear:** `/Core/Performance/MemoryMonitor.swift`

```swift
import Foundation

/// Monitor de uso de memoria
actor MemoryMonitor {

    // MARK: - Singleton

    static let shared = MemoryMonitor()

    // MARK: - Configuration

    /// Umbral de warning (MB)
    let warningThresholdMB: UInt64 = 200

    /// Umbral critico (MB)
    let criticalThresholdMB: UInt64 = 400

    // MARK: - Dependencies

    private let logger = LoggerFactory.performance

    // MARK: - Public Methods

    /// Obtiene uso actual de memoria
    func getCurrentMemoryUsage() -> MemoryUsage {
        var info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size) / 4

        let result = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)
            }
        }

        let usedMB = result == KERN_SUCCESS ? UInt64(info.resident_size) / 1024 / 1024 : 0

        return MemoryUsage(
            usedMB: usedMB,
            warningThreshold: warningThresholdMB,
            criticalThreshold: criticalThresholdMB
        )
    }

    /// Verifica estado de memoria y genera alertas si necesario
    func checkMemoryStatus() {
        let usage = getCurrentMemoryUsage()

        if usage.usedMB > criticalThresholdMB {
            logger.critical("Critical memory usage: \(usage.usedMB)MB")
        } else if usage.usedMB > warningThresholdMB {
            logger.warning("High memory usage: \(usage.usedMB)MB")
        }
    }

    /// Inicia monitoreo periodico
    func startPeriodicMonitoring(interval: TimeInterval = 60) {
        Task {
            while true {
                try? await Task.sleep(nanoseconds: UInt64(interval * 1_000_000_000))
                checkMemoryStatus()
            }
        }
    }
}

struct MemoryUsage: Sendable {
    let usedMB: UInt64
    let warningThreshold: UInt64
    let criticalThreshold: UInt64

    var status: MemoryStatus {
        if usedMB > criticalThreshold {
            return .critical
        } else if usedMB > warningThreshold {
            return .warning
        }
        return .normal
    }
}

enum MemoryStatus {
    case normal
    case warning
    case critical
}
```

#### Fase 6: Performance Dashboard (1.5h)

**Crear:** `/Presentation/Scenes/Debug/PerformanceDashboardView.swift`

```swift
import SwiftUI

/// Dashboard de metricas de performance (solo debug)
struct PerformanceDashboardView: View {

    @State private var stats: PerformanceStats?
    @State private var memoryUsage: MemoryUsage?
    @State private var recentMetrics: [PerformanceMetric] = []

    var body: some View {
        List {
            // Stats Section
            Section("Estadisticas") {
                if let stats = stats {
                    StatRow(title: "Launch Time Promedio", value: formatTime(stats.averageLaunchTime))
                    StatRow(title: "Screen Render Promedio", value: formatTime(stats.averageScreenRender))
                    StatRow(title: "Network Request Promedio", value: formatTime(stats.averageNetworkRequest))
                    StatRow(title: "Total Metricas", value: "\(stats.totalMetrics)")
                }
            }

            // Memory Section
            Section("Memoria") {
                if let memory = memoryUsage {
                    StatRow(title: "Uso Actual", value: "\(memory.usedMB) MB")
                    StatRow(title: "Estado", value: memory.status.description)
                        .foregroundColor(memory.status.color)
                }
            }

            // Recent Metrics
            Section("Metricas Recientes") {
                ForEach(recentMetrics.prefix(20), id: \.timestamp) { metric in
                    MetricRow(metric: metric)
                }
            }
        }
        .navigationTitle("Performance")
        .task {
            await loadData()
        }
        .refreshable {
            await loadData()
        }
    }

    private func loadData() async {
        stats = await PerformanceMonitor.shared.getStats()
        memoryUsage = await MemoryMonitor.shared.getCurrentMemoryUsage()
        recentMetrics = await PerformanceMonitor.shared.getRecentMetrics()
    }

    private func formatTime(_ time: TimeInterval) -> String {
        String(format: "%.2f s", time)
    }
}

struct StatRow: View {
    let title: String
    let value: String

    var body: some View {
        HStack {
            Text(title)
            Spacer()
            Text(value)
                .foregroundColor(.secondary)
        }
    }
}

struct MetricRow: View {
    let metric: PerformanceMetric

    var body: some View {
        VStack(alignment: .leading) {
            Text(metric.name)
                .font(.body)
            HStack {
                Text(String(format: "%.2f s", metric.duration))
                    .font(.caption)
                    .foregroundColor(.secondary)
                if let screen = metric.metadata["screen_name"] {
                    Text("- \(screen)")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
        }
    }
}

extension MemoryStatus {
    var description: String {
        switch self {
        case .normal: return "Normal"
        case .warning: return "Warning"
        case .critical: return "Critico"
        }
    }

    var color: Color {
        switch self {
        case .normal: return .green
        case .warning: return .orange
        case .critical: return .red
        }
    }
}
```

### Criterios de Aceptacion SPEC-012

- [ ] PerformanceMonitor actor
- [ ] Launch time tracking
- [ ] Screen render tracking
- [ ] Network performance tracking
- [ ] Memory monitoring
- [ ] Performance dashboard (debug)
- [ ] Tests (6+)
- [ ] Documentacion

**Estimacion Total:** 16 horas

---

## Priorizacion Recomendada

### Orden de Implementacion

1. **SPEC-009 (Feature Flags)** - 12h
   - **Justificacion:** Sin bloqueadores, habilita las otras dos
   - **Beneficio:** Permite experimentacion A/B
   - **Riesgo:** Bajo

2. **SPEC-011 (Analytics)** - 14h
   - **Justificacion:** Requiere Firebase pero puede avanzar localmente
   - **Beneficio:** Datos para decisiones de producto
   - **Riesgo:** Medio (privacy compliance)

3. **SPEC-012 (Performance)** - 16h
   - **Justificacion:** Se beneficia de analytics para envio de metricas
   - **Beneficio:** Optimizacion de app
   - **Riesgo:** Bajo

### Factores de Decision

| Factor | 009 | 011 | 012 |
|--------|-----|-----|-----|
| Sin bloqueadores | Si | No (Firebase) | Parcial |
| Valor inmediato | Alto | Medio | Bajo |
| Complejidad | Media | Media | Media |
| Dependencias | Ninguna | Firebase | SPEC-011 |
| **Prioridad** | **1** | **2** | **3** |

---

## Dependencias Entre SPECs

### Diagrama de Dependencias

```
SPEC-009 (Feature Flags)
    │
    ├───────────────────────────┐
    │                           │
    ▼                           ▼
SPEC-011 (Analytics)      SPEC-012 (Performance)
    │                           │
    └───────────┬───────────────┘
                │
                ▼
        [Shared Infrastructure]
        - Logging (SPEC-002)
        - SwiftData (SPEC-005)
        - Offline (SPEC-013)
```

### Tabla de Dependencias

| SPEC | Depende de | Habilita | Comparte con |
|------|------------|----------|--------------|
| 009 | SPEC-005 (SwiftData) | 011, 012 | - |
| 011 | SPEC-009, Firebase | 012 | Consent con 012 |
| 012 | SPEC-011 (opcional) | - | Logging con 011 |

### Infraestructura Compartida

Componentes que pueden reutilizarse:

1. **UserConsentManager** (011) - Usable por 012
2. **PerformanceMonitor** (012) - Usado por 011 para metricas
3. **FeatureFlagRepository** (009) - Controla habilitacion de 011 y 012

---

## Timeline Consolidado

### Sprint +2: SPEC-009 (3 semanas)

| Semana | Tareas | Horas |
|--------|--------|-------|
| 1 | Fases 1-2 (Enum, Protocol, Local) | 3h |
| 2 | Fase 3 (Remote Config) | 3h |
| 3 | Fases 4-5 (A/B, Admin UI) + Tests | 6h |
| **Total** | | **12h** |

### Sprint +3: SPEC-011 (3 semanas)

| Semana | Tareas | Horas |
|--------|--------|-------|
| 1 | Fases 1-2 (Protocol, Manager) | 3h |
| 2 | Fase 3 (Firebase) - si credentials | 3h |
| 3 | Fases 4-5 (Privacy, Consent UI) + Tests | 8h |
| **Total** | | **14h** |

### Sprint +4: SPEC-012 (3 semanas)

| Semana | Tareas | Horas |
|--------|--------|-------|
| 1 | Fases 1-2 (Monitor, Launch) | 4h |
| 2 | Fases 3-4 (Screen, Network) | 5h |
| 3 | Fases 5-6 (Memory, Dashboard) + Tests | 7h |
| **Total** | | **16h** |

### Timeline Total

| Sprint | SPEC | Inicio | Fin | Horas |
|--------|------|--------|-----|-------|
| +2 | 009 | Semana 5 | Semana 7 | 12h |
| +3 | 011 | Semana 8 | Semana 10 | 14h |
| +4 | 012 | Semana 11 | Semana 13 | 16h |
| **Total** | | | | **42h** |

---

## Verificacion Post-Implementacion

### Checklist SPEC-009

- [ ] FeatureFlag enum con flags definidos
- [ ] Repository con persistencia SwiftData
- [ ] Remote config service (opcional)
- [ ] Debug UI funcional
- [ ] Tests pasando

### Checklist SPEC-011

- [ ] AnalyticsService multi-provider
- [ ] Firebase integrado (cuando disponible)
- [ ] Consent management completo
- [ ] Privacy compliance
- [ ] Tests pasando

### Checklist SPEC-012

- [ ] PerformanceMonitor operativo
- [ ] Launch time tracking
- [ ] Screen render tracking
- [ ] Memory monitoring
- [ ] Dashboard funcional
- [ ] Tests pasando

---

**Documento generado:** 2025-11-28
**Lineas totales:** 850
**Siguiente documento:** 05-ROADMAP-SPRINTS.md
